---
title: "Temporal analysis: model fitting 1"
description: |
  Fitting of the population dynamic model to non-replicated disease progress curve data
author:
  - name: Emerson M. Del Ponte
    url: https://emersondelponte.netlify.app
    affiliation: Universidade Federal de Vi√ßosa
    affiliation_url: https://www.ufv.br/dfp
date: "`r Sys.Date()`"
site: distill::distill_website
bibliography: references.bib
output:
  distill::distill_article:
    toc: true
    toc_depth: 3
---

In this tutorial you will learn how to fit models to multiple actual disease progress curves (DPCs) data obtained from the literature. I will demonstrate how to fit and select the models using a new R package called *epifitter*. A few user friendly functions will help us decide which model to choose to obtain the parameters of interest and further compare the epidemics.

To illustrate, I will use two datasets available from Chapter 3 from the book, *Study of Plant Disease Epidemics* [@madden2017]. In the book, SAS codes are presented to perform a few analysis. We then provide an alternative code for performing similar analysis, although not identically reproducing the results from the book.

# Non-replicated epidemics

Here we will compare three DPCs of the incidence of tobacco etch, a virus disease, in peppers. Evaluations of incidence were evaluated at a 7-day interval up to 49 days. The data are available in chapter 4 (page 93) [@madden2017]. Let's input the data manually and create a data frame. First column is the assessment time and the other columns correspond to the treatments, called groups in the book, from 1 to 3.

## Initial setup

Load essential packages and set parameters recursively.

```{r}
library(tidyverse)
library(knitr)
library(patchwork)
library(ggthemes)
theme_set(theme_few())
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE)
options(digits = 3)
```

## Entering data

```{r}

pepper <- 
  tibble::tribble(
   ~t,  ~`1`,  ~`2`,  ~`3`,
   0,  0.08, 0.001, 0.001,
   7,  0.13,  0.01, 0.001,
  14,  0.78,  0.09,  0.01,
  21,  0.92,  0.25,  0.05,
  28,  0.99,   0.8,  0.18,
  35, 0.995,  0.98,  0.34,
  42, 0.999,  0.99,  0.48,
  49, 0.999, 0.999,  0.74
  ) 


```

## Visualize the DPCs

Before proceeding with model selection and fitting, let's visualize the three epidemics. The code below reproduces quite exactly the top plot of Fig. 4.15 ([@chapter2017b] page 94). The appraisal of the curves might give us a hint on which models are the best candidates.

Because the data was entered in the wide format (each DPCs in a different columns) we need to reshape it to the tidyverse-suitable format, which is the long format. The `pivot_longer` function will do the job of reshaping from wide to long format so we can finally use the `ggplot` function to produce the plot.

```{r, echo = TRUE}
   
pepper %>% 
  pivot_longer(2:4, names_to ="treat", values_to = "inc") %>% 
  ggplot (aes(t, inc, 
              linetype = treat, 
              shape = treat, 
              group = treat))+
  geom_point(size =2)+
  geom_line()+
  annotate(geom = "text", x = 15, y = 0.84, label = "1")+
  annotate(geom = "text", x = 23, y = 0.6, label = "2")+
  annotate(geom = "text", x = 32, y = 0.33, label = "3")+
  labs(y = "Disease incidence (y)",
       x = "Time (days)")+
  theme(legend.position = "none")

```

Most of the three curves show a sigmoid shape with the exception of group 3 that resembles an exponential growth, not reaching the maximum value, and thus suggesting an incomplete epidemic. We can easily eliminate the monomolecular and exponential models and decide on the other two non-flexible models: logistic or Gompertz. To do that, let's proceed to model fitting and evaluate the statistics for supporting a final decision. There are two modeling approaches for model fitting in epifitter: the **linear** or **nonlinear** parameter-estimation methods.

## Fitting: single epidemics

Among the several options offered by *epifitter* we start with the simplest one, which is fit a model to a single epidemics using the linear regression approach. For such, the `fit_lin()` requires two arguments: time (`time`) and disease intensity (`y`) each one as a vector stored or not in a dataframe.

Since we have three epidemics, `fit_lin()` will be use three times. The function produces a list object with six elements. Let's first look at the `Stats` dataframe of each of the three lists named `epi1` to `epi3`.

```{r}
library(epifitter)

epi1 <- fit_lin(time = pepper$t,  
  y = pepper$`1` )
epi1$Stats


```

```{r}
epi2 <- fit_lin(time = pepper$t,  
  y = pepper$`2` )
epi2$Stats
```

```{r}
epi3 <- fit_lin(time = pepper$t,  
  y = pepper$`3` )
epi3$Stats

```

The statistics of the model fit confirms our initial guess that the predictions by the logistic or the Gompertz are closer to the observations than predictions by the other models. There is no much difference between them based on these statistics. However, to pick one of the models, it is important to inspect the curves with the observed and predicted values to check which model is best for all curves.

## Fitting: multiple epidemics

Before looking at the prediction, let's use another handy function that allows us to simultaneously fit the models to multiple DPC data. Different from `fit_lin()`, `fit_multi()` requires the data to be structured in the long format where there is a column specifying each of the epidemics.

Let's then create a new data set called `pepper2` using the data transposing functions of the *tidyr* package.

```{r}
pepper2 <- pepper %>% 
  pivot_longer(2:4, names_to ="treat", values_to = "inc")


```

Now we fit the models to all DPCs. Note that the name of the variable indicating the DPC code needs to be informed in `strata_cols` argument.

```{r}
epi_all <- fit_multi(
  time_col = "t",
  intensity_col = "inc",
  data = pepper2,
  strata_cols = "treat",
  nlin = FALSE
)



```

Now let's select the statistics of model fitting. Again, *Epifitter* ranks the models based on the CCC (the higher the better) but it is important to check the RSE as well - the lower the better. In fact, the RSE is more important when the goal is prediction.

```{r echo=TRUE}
epi_all$Parameters %>% 
  select(treat, model, best_model, RSE, CCC)
```

To be more certain about our decision, let's advance to the final step which is to produce the plots with the observed and predicted values for each assessment time by calling the `Data` dataframe of the \``epi_all` list.

```{r, echo = TRUE}
epi_all$Data %>%
 filter(model %in% c("Gompertz", "Logistic")) %>% 
  ggplot(aes(time, predicted, shape = treat)) +
  geom_point(aes(time, y)) +
  geom_line() +
  facet_wrap(~ model) +
 coord_cartesian(ylim = c(0, 1)) + # set the max to 0.6
  labs(
    y = "Disease incidence",
    x = "Time (days after emergence)"
  )
```

Overall, the logistic model seems a better fit for all the curves. Let's produce a plot with the prediction error versus time.

```{r echo=TRUE}
epi_all$Data %>%
 filter(model %in% c("Gompertz", "Logistic")) %>% 
  ggplot(aes(time, predicted -y, shape = treat)) +
  geom_point() +
  geom_line() +
  geom_hline(yintercept = 0, linetype =2)+
  facet_wrap(~ model) +
 coord_cartesian(ylim = c(-0.4, 0.4)) + # set the max to 0.6
  labs(
    y = "Prediction error",
    x = "Time (days after emergence)"
  )
```

The plots above confirms the logistic model as good fit overall because the errors for all epidemics combined are more scattered around the non-error line.

```{r, echo = TRUE}

  epi_all$Parameters %>%
    filter(model == "Logistic") %>%
    select(treat, y0, y0_ci_lwr, y0_ci_upr, r, r_ci_lwr, r_ci_upr 
)
```

We can produce a plot for visual inference on the differences in the parameters.

```{r, echo = TRUE}

p1 <- epi_all$Parameters %>%
  filter(model == "Logistic") %>%
  ggplot(aes(treat, r)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = r_ci_lwr, ymax = r_ci_upr),
    width = 0,
    size = 1
  ) +
  labs(
    x = "Time",
    y = "r"
  )

p2 <- epi_all$Parameters %>%
  filter(model == "Logistic") %>%
  ggplot(aes(treat, 1 - exp(-y0))) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = y0_ci_lwr, ymax = y0_ci_upr),
    width = 0,
    size = 1
  ) +
  labs(
    x = "Time",
    y = "y0"
  )

p1 | p2

```
