---
title: "Population level models"
description: |
  Fitting and choosing the best fitted model to disease progress curve data obtained in replicated experiments.
---



# Apresentação

Neste tutorial será demonstrada a escolha de um modelo específico para os dados de progresso de doença com base em procedimentos gráficos e estatísticos. Os dados são os mesmos apresentados em Madden et al. (2007, pág. 85) do progresso de um vírus do tabaco. Os procedimentos seguem aqueles também apresentados no livro (Madden et al., 2007).

# Conjunto de dados

Os dados abaixo representam os dados de incidência observados em intervalos de sete dias, para o progresso do vírus do tabaco, avaliados até 49 dias após o início da epidemia. 

```{r}

#Gera uma sequencia de oito das de avaliação, do dia 0 a 49, a cada sete dias.
t = seq(0,49,7)

#Atribui os valores de incidência em %
inc = c(0.1, 1, 9, 25, 80, 98, 99, 99.9)

# Transforma os valores para proporção (0 a 1)
y = inc/100
curva1 <- data.frame(t, y)
```



Abaixo, o programa para gerar o gráfico da curva de progresso da incidência no tempo


```{r, echo=FALSE}
plot ( y ~ t, data=curva1, main="Curva de progresso", type=c("p"), ylab="Incidencia (%)", xlab="Tempo (dias)")
       
```

# Cálculo da taxa absoluta 
A taxa absoluta é a diferença de y entre dois tempos da epidemia, que é dada por:

`dy/dt = (y2 - y1) / (t2 - t1)`

No cálculo abaixo, uma vez que os intervalos são fixos em 7 dias, foi criada uma variável `dydt` apenas com a subtração entre um tempo t e o tempo anterior.

```{r}
dydt = c(0,
 curva1[2,2]-curva1[1,2],
 curva1[3,2]-curva1[2,2],
 curva1[4,2]-curva1[3,2],
 curva1[5,2]-curva1[4,2],
 curva1[6,2]-curva1[5,2],
 curva1[7,2]-curva1[6,2])

# Divide todos os valores por sete, já que é fixo nesse caso
dydt = dydt/7
dydt # apresenta os dados
```


Para produzir um gráfico da taxa absoluta no tempo, o tempo é na verdade a média entre dois tempois. De maneira simples, pode-se calcular o tempo médio entre dois tempos. Abaixo, o tempo médio é atribuído à variável `t2`.

```{r}
t2 = c(0, 
 (curva1[2,1]+curva1[1,1])/2,
 (curva1[3,1]+curva1[2,1])/2,
 (curva1[4,1]+curva1[3,1])/2,
 (curva1[5,1]+curva1[4,1])/2,
 (curva1[6,1]+curva1[5,1])/2,
 (curva1[7,1]+curva1[6,1])/2)
t2
```

Assim como para o tempo, se calcula a média de incidência entre duas avaliações, atribuída a variável `y2`.

```{r, echo=FALSE}
y2 = c(0, 
 (curva1[2,2]+curva1[1,2])/2,
 (curva1[3,2]+curva1[2,2])/2,
 (curva1[4,2]+curva1[3,2])/2,
 (curva1[5,2]+curva1[4,2])/2,
 (curva1[6,2]+curva1[5,2])/2,
 (curva1[7,2]+curva1[6,2])/2)
y2
```

A seguir, as duas curvas podem ser plotadas

```{r}
par(mfrow=c(1,2))
plot (dydt ~ t2, xlim=c(0,50), type="o", 
      ylab="Taxa absoluta (dy/dt)", xlab = "Tempo (dias)")

plot (dydt ~ y2, type="o", 
      ylab="Taxa absoluta (dy/dt)", xlab="Incidencia (y)")
```


## Linearizações de y* 

A análise gráfica envolve a visualização de y* (y linearizado) no tempo. Para tal, aplica-se as transformações que linearizam para cada um dos modelos. No exemplo, serão feitas linearizações para cinco modelos. 

```{r}

# Abaixo, cria-se uma variável de cada vez e adiciona no conjunto de dados curva1
curva1$yexp = log(y)                # exponito
curva1$ymon = log(1/(1-y))          # monito
curva1$ylog = log(y/(1-y))          # logito
curva1$ygom = -log(-log(y))         # gompito
curva1$yric3 = log(1 / (y^(1-3)-1)) # richards (n=3)

# apresenta o conjunto de dados com as variáveis novas adicionadas
curva1
```

Análise gráfica das transformações. A curva que for mais "reta" indica o possível modelo que melhor se ajusta aos dados.

```{r}

par(mfrow=c(2,3))

plot (yexp ~ t, data=curva1, main="Exponencial", type=c("o"), 
      ylab="Exponito", xlab="Tempo (dias)")

plot (ymon ~ t, data=curva1, main="Monomolecular", type=c("o"),
      ylab="Monito", xlab="Tempo (dias)")

plot (ylog ~ t, data=curva1, main="Logistico", type=c("o"),
      ylab="Logito", xlab="Tempo (dias)")

plot (ygom ~ t, data=curva1, main="Gompertz", type=c("o"),
      ylab="Gompito", xlab="Tempo (dias)")

plot (yric3 ~ t, data=curva1, main="Richards (n=3)", type=c("o"),
      ylab="Richard (n=3)",  xlab="Tempo (dias)")

```

## Ajuste por regressão linear

Aqui o ajuste ao modelo linear será com os dados transformados de y (y*) , para cada um dos modelos que supostamente tem melhor ajuste, no tempo. Abaixo a regressão linear para o logito versus tempo e gompito versus tempo, já que a curva é sigmóide e a análise visual indica que esses dois modelos parecem descrever adequadamente a epidemia.


```{r}

# Aplica a regressão linear para o logito
reg_log = lm(ylog ~ t, data=curva1)

# apresenta os dois coeficientes do modelo linear
coef(reg_log) 

# Mostra o intervalo de confiança dos parâmetros
c = confint(reg_log)
c
# aplica função inversa para o intercepto para obter o y0
conf = 1/(1+exp(-c[1])) # apenas para o intercepto
conf

# Regressão linear para o gompito
reg_gom = lm(ygom ~ t, data=curva1)

# apresenta os dois coeficientes do modelo linear
coef(reg_gom) 

# Mostra o intervalo de confiança dos parâmetros
c= confint(reg_gom)
c
# aplica função inversa para o intercepto para obter o y0

conf = 1/(1+exp(-c[1])) # apenas para o intercepto
conf
```

Abaixo, os gráficos da regresão linear para cada modelo
```{r}
par(mfrow=c(1,2))

plot (ylog ~ t, data=curva1, main="Logistico", type=c("p"),
      ylab="Logito", xlab="Tempo (dias)")

#abline (coef(reg_log)) # apresenta a linha da regressão
abline (coef(reg_log))

# adiciona a equação no gráfico
lm_coef <- round(coef(reg_log), 3) # extrai os coeficientes
mtext(bquote(y == .(lm_coef[1]) + .(lm_coef[2])*t), adj=0, padj=0) # Mostra a equação

plot ( ygom ~ t, data=curva1, main="Gompertz", type=c("p"),
      ylab="Gompito", xlab="Tempo (dias)"
      )
abline (coef(reg_gom))

# adiciona a equação no gráfico
lm_coefg <- round(coef(reg_gom), 3) # extrai os coeficientes
mtext(bquote(y == .(lm_coefg[1]) + .(lm_coefg[2])*t), adj=0, padj=0) # mostra a equação equation 
```

Abaixo, os gráficos dos resíduos


```{r}
par(mfrow=c(1,2))
# cria o vetor dos resíduos do modelo logístico
res_log = resid(reg_log)

# gráfico dos resíduos
plot ( res_log ~ t, main="Logistico",  ylab="Residuos", xlab ="Tempo (dias)")
abline(h=0) # cria uma linha horizontal para y=0

# cria o vetor dos resíduos do modelo Gompertz
res_gom = resid(reg_gom)

plot(res_gom ~ t, main="Gompertz", ylab="Residuos", xlab ="Tempo (dias)")
abline(h=0)

```


### Avalia o R*<sup>2</sup>

Avalia o ajuste dos modelos com base no R2 ajustado da relação linear entre o log(y) versus o predito pelo modelo linear.

```{r}

# MODELO LOGÍSTICO
# Cria a variável com o valor predito pelo modelo logístico
curva1$pred_logito <- lm_coef[1] + (lm_coef[2]*t)
curva1 = round(curva1, 3) # arredonda os valores para 3 casas
# Mostra o conjunto de dados com a nova variável
curva1

# Ajusta um modelo linear para predito versus y transformado para log
ajuste_log = lm(ylog ~ pred_logito, data=curva1)
# Mostra o R2 do ajuste
summary(ajuste_log)$r.squared
# Mostra os coeficientes
summary(ajuste_log)$coef


mean(ajuste_log$residuals^2) # quadrado médio dos resíduos
sqrt(mean(ajuste_log$residuals^2)) # raiz do quadrado médio dos resíduos (do inglês, RMSE)

# Gráficos de diagnóstico do modelo 
par(mfrow=c(1,2))
plot(ajuste_log, which=1:2) # mostra os resíduos e o qq-plot


# MODELO DE GOMPERTZ
# Cria a variável dos valores preditos pelo modelo linear 
curva1$pred_gompito <- lm_coefg[1] + (lm_coefg[2]*t)
curva1 = round(curva1, 3)
curva1

# Ajusta o modelo linear
ajuste_gomp = lm(ygom ~ pred_gompito, data=curva1)
# Mostra o coeficiente de determinação do modelo
summary(ajuste_gomp)$r.squared
# Mostra os coeficientes
summary(ajuste_gomp)$coef
sqrt(mean(ajuste_gomp$residuals^2))

# Gráficos de avaliação do ajuste 
par(mfrow=c(1,2))
plot(ajuste_gomp, which = 1:2) # mostra os resíduos e o qq-plot

```


### Estima y 

```{r}

# Cria um gráfico do progresso da doença

par(mfrow=c(1,2))
plot (y ~ t, data=curva1, main="Logistico",  type=c("p"),
      ylab="Incidencia (%)", xlab="Tempo (dias)")

lm_coefl <- round(coef(reg_log), 3)
lm_coefl
y0 = 1/ (1+exp(-lm_coefl[1]))  # y0 estimado
y0
 
# Entra com os dados para gerar a curva do modelo
max=50
r = lm_coefl[2]
# Estimado da taxa r do logístico
     
curve( 1/(1+((1-y0)/y0)*exp(-r*x)), from=0, to=max, add=T, ylab="y", xlab="t", ylim=c(0,1), lty=1, lwd=2)

# curva do modelo de gompertz
plot ( y ~ t, data=curva1, main="Gompertz", type=c("p"),
      ylab="Incidencia (%)", xlab="Tempo (dias)")

lm_coefg <- round(coef(reg_gom), 3)
lm_coefg
y0 = exp(-exp(-lm_coefg[1])) # Estimado y0 do gompertz
y0

max=50
r = lm_coefg[2]
# Estimado da taxa do modelo gompertz
curve(exp(log(y0)*exp(-r*x)), from=0, to=max, add=T, ylab="y", xlab="t", ylim=c(0,1), lty=1, lwd=2)

```

##  Regressão não linear
Existem alguns modelos complexos que não podem ser linearizados ou que mesmo que seja possível, os parâmetros podem ser estimados por métodos não lineares. Nesse caso, o processo de ajuste não linear no R é similar ao ajuste de modelos lineares, exceto pelo fato de que não há uma fórmula explícita para estimação, então procedimentos iterativos são necessários, exigindo que o usuário entre com estimativas iniciais dos parâmetros.

### Logístico

No R, os modelo não lineares são ajustados com a função `nls`. Abaixo um exemplo de ajuste do modelo logístico. Note que os parâmetros iniciais de `k`, `y0` e `r` precisam ser informados para dar início ao processo de estimação. O `k` equivale à intensidade máxima de doença e no exemplo abaixo é estimado ao invés de considerar o máximo com o valor 1, no caso de epidemias completas. Em muitos casos as epidemias não chegam ao máximo e portanto `k` precisa ser informado para que não ocorre erro na estimativa dos outros dois parâmetros.


```{r}

# os dados serão os mesmos utilizados anteriormente
t = seq(0,49,7)
# atribui os valores de incidência em %
inc = c(0.1, 1, 9, 25, 80, 98, 99, 99.9)
# Transforma os valores para proporção (0 a 1)
y = inc/100

# ajusta o modelo logístico. Os parâmetros iniciais foram ao redor dos valores estimados para o ajuste por regressão linear


nl_logistico = nls(y~k/(1+(k/y0-1)*exp(-r*t)),start=list(k=1.1,y0=0.001,r=0.27))

# mostra os valores dos três parâmetros
coef(nl_logistico)

# grava os valores com 4 casas decimais
coef_nl_log = round(coef(nl_logistico),4)

# note que os valores não são os mesmos estimados pela regressão linear entre o logito e os dados observados, onde y0= 0.0013 e r = 0.27
coef_nl_log

# apresenta a estatítica completa com o erro padrão dos parâmetros e o R2
summary(nl_logistico)

# gera um gráfico com os dados originais e preditos pelo modelo
par(mfrow=c(1,1))
plot (y ~ t, data=curva1, main="Modelo logistico", type="p", 
      ylab="Incidencia (%)", xlab="Tempo (dias)")

# plota a linha do modelo chamando pelos respectivos parâmetros estimados acima 
curve(coef_nl_log[1]/(1+exp(-log(coef_nl_log[2]/(1-coef_nl_log[2]))-coef_nl_log[3]*x)), from=t[1],to=t[8], add=TRUE)

# faz o gráfico da relação entre o observado e o predito pelo modelo
plot (y ~predict(nl_logistico), xlim=c(0,1), ylim=c(0,1))
lm_predobs = lm(y ~ predict(nl_logistico))
abline(lm_predobs)
abline(0,1, lty=2)
summary(lm_predobs)

```

### Gompertz

No modelo de Gompertz, iremos utilizar a mesma função. No entanto, algumas vezes a função nls tem problemas para convergir a partir dos dados iniciais atriuídos para inicializar o modelo. No exemplo abaixo será utilizada função `nlsLM` do pacote `minpack.lm`

```{r}
library(minpack.lm)

# novamente vamos inicializar o processo com os valores dos parâmetros ao redor daqueles estimados pela regressão linear
nl_gompertz = nlsLM(y~k*exp(log(y0/k)*exp(-r*t)),start=list(k=1,y0=0,r=0.17))
coef(nl_gompertz)
# mostra os parâmetros ajustados



# o modelo abaixo, se utilizado com a função nls irá produzir um erro do tipo "singular gradient matrix at initial parameter estimates". Isso se deve à forma como é feita a estimação. Veja mais detalhes no pacote minpack.lm
# gompertz = nls(y~k*exp(log(y0/k)*exp(-r*t)),start=list(k=0.9,y0=0,r=0.19))
#lm_coef <- round(coef(gompertz), 12)
#lm_coef

# gera um gráfico com os dados originais e preditos pelo modelo
par(mfrow=c(1,1))
plot (y ~ t, data=curva1, main="Modelo Gompertz", type="p", 
      ylab="Incidencia (%)", xlab="Tempo (dias)")

# plota a linha do modelo chamando pelos respectivos parâmetros estimados acima 

curve(coef(nl_gompertz)[1]*exp(log(coef(nl_gompertz)[2]/coef(nl_gompertz)[1])*exp(-coef(nl_gompertz)[3]*x)), from=0, to=max, add=T, ylab="y", xlab="t", ylim=c(0,1), lty=1, lwd=2)




# apresenta o gráfico
plot (predict(nl_gompertz)~y, xlim=c(0,1), ylim=c(0,1))
lm_predobs_g = lm(predict(nl_gompertz) ~ y)
abline(lm_predobs_g)
abline(0,1, lty=2)
summary(lm_predobs_g)



```

### Monomolecular

```{r}
# dados de severidade do carvão da cana-de-açúcar em %
ym = c(3.9,20,43.7,66.2,82.4,91.3,94.4,96,97.1,98,98.5,99)
# transforma para proporção
ym2 = ym/100

# dias após o plantio
tm = c(22,28,34,49,63,78,91,105,119,133,147,163)
# faz a correção para a epidmeia ter início no tempo 0 
tm2 = c(0,6,12,27,41,56,69,83,97,111,125,141)

# ajusta o modelo de regressão não linear
nl_mono= nlsLM(ym2~1-(1-y0)*exp(-r*tm2), start=list(y0=0.01,r=0.2))
#coeficientes
coef(nl_mono)
#sumário da regressão
summary(nl_mono)

# faz o gráfico dos dados observados
par(mfrow=c(1,1))
plot (ym2 ~ tm2, data=curva1, main="Modelo monomolecular", type="p", 
      ylab="Incidencia (%)", xlab="Tempo (dias)")
# plota a linha do modelo com os respectivos parâmetros estimados acima 
curve(1-((1-coef(nl_mono)[1])*exp(-coef(nl_mono)[2]*x)),from=0,to=170, lty=1, lwd=2, add=T) # o add=T permite incluir a curva no mesmo gráfico
```



```


