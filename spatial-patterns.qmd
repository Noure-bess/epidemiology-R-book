# Spatial patterns

## Introduction

A spatial disease pattern can be defined as the arrangement of diseased entities relative to each other and to the architecture of the host crop [@chapter2017] . Such arrangement is the realization of the underlying dispersal of the pathogen, from one or several sources within and/or outside the area of interest, under the influence of physical, biological and environmental factors.

The study of spatial patterns is conducted at a specific time or multiple times during the epidemic. When assessed multiple times, both spatial and temporal processes can be characterized. Because epidemics change over time, it is expected that spatial patterns are not constant but change over time as well. Usually, plant pathologists are interested in determining spatial patterns at one or various spatial scales, depending on the objective of the study. The scale of interest may be a leaf or root, plant, field, municipality, state, country or even intercontinental area. The diseased units observed may vary from lesions on a single leaf to diseased fields in a large production region.

The patterns can be classified into two main types that occur naturally: **random** or **aggregated**. The random pattern originates because the chances for the units (leaf, plant, crop) to be infected are equal and low, and are largely independent from each other. In aggregated spatial patterns, such chances are unequal and there is dependency among the units, for example, a healthy unit close to a diseased unit is at higher risk than more distant units.

A range of techniques, most based on statistical tests, can be used to detect deviations from randomness in space and the choice of the methods depends on the scale of observation. Usually, more than one test is applied for the same or different scales of interest depending on how the data are collected. Three general categories of statistical tests can be determined based on the spatial scale and type of data collected: position of diseased units within a row or series of rows (plant to plant); quadrat or plot count data; or distance among the diseased units.

## Position and status within a row (plant to plant)

Here, the status of each unit (usually a plant) is noted as a nominal variable. The plant is either diseased (D or 1) or non-diseased or healthy (H or 0). These data are usually collected within a crop row, giving rise to a series of binary data. Several statistical tests can be used to detect a deviation from randomness. The most commonly used tests are **runs**, **doublets** and **joint count** statistics.

### Runs test

The runs test. Description.

Let's create a vector of binary (0 = non-diseased; 1 = diseased) data representing a crop row with 20 plants and assign it to `y`. For plotting purposes, we make a dataframe for more complete information.

```{r}
y1 <- c(1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,1,1)
x1 <- c(1:20) # position of each plant
z1 <- 1
row1 <- data.frame(x1, y1, z1) # create a dataframe
```

We can then visualize the series using ggplot.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
row1 %>% 
  ggplot(aes(x1, z1, label = x1, color = factor(y1)))+
  geom_point(shape =15, size =6)+
  theme_void()+
  scale_x_continuous(breaks = max(z1))+
  scale_color_manual(values = c("green", "red"))+
  geom_text(vjust = 0, nudge_y = 0.5)+
coord_fixed()+
  ylim(-0.5,2.5)+
  theme(legend.position = "right")+
  labs(color = "Status", title = "Sequence of diseased (1) or non-diseased (0) units (plants)", 
       subtitle = "The numbers represent the position of the unit")
```

We can write a code in R and create a function named `oruns.test` for the ordinary runs test.

```{r}
oruns.test <- function(x) {
# identify the sequence
S <- x 
# Compute the number or runs
U = max(cumsum(c(1, diff(S)!=0)))
# Compute the number of diseased plants
m = sum(S)
# Count the total number of plants
N = length(S)
# Calculate the number of expected runs
EU = 1 + (2 * m*(N - m)/N)
# Calculate the standard deviation in the sample
sU = sqrt(2 * m * (N - m) * (2 * m *(N-m)-N)/ (N^2 *(N-1)))
# Calculate the z-value
Z = (U - EU)/sU
# Obtain the p-value for the Z
pvalue <- (2*pnorm(abs(Z), lower.tail=FALSE))
# test if Z is lower than 1.64
result <- ifelse(Z < 1.64, 
c("clustering"), 
c("randomness"))
# Print the results
print(paste("There are",U,"runs. The number of expected runs is", round(EU,1), "P-value:",round(pvalue,6), ". Alternative hypothesis: non-randomness"))
}
```

We can now run the test for the example series above.

```{r}
oruns.test(row1$y1)
```

There are built-in functions in R packages that allow for running the ordinary runs test. Let's load the packages and runt the test. Note that the results of the `runs.test` is the same as the one produced by our custom function.

```{r}
library(randtests)
runs.test(row1$y1, threshold = 0.5)

library(DescTools)
r <- RunsTest(row1$y1)

```

### Doublets

The doublets test. Description.

Let's manually produce a code to execute the doublets test. To facilitate, we can create a function and name it `doublets.test`. The only argument needed is the vector of binary data.

```{r}
doublets.test <- function(x) {
# Identify the sequence
S <- x
# Compute the number of doublets Db
matrix <- cbind(S[-length(S)], S[-1])
pairs <- table(data.frame(matrix))
Db <- pairs[2,2]
# Count the number of diseased plants
N <- length(S) 
# Count the number of total plants
m = sum(S) 
# Expected number of doublets
EDb = m *((m -1)/N)
# Standard deviation 
SDb = sqrt ( EDb * (1 - (2 / N)))
# Calculate the Z-value 
ZDb = (Db - EDb)/ SDb 
# two-sided P-value calculation
pvalue <- (2*pnorm(abs(ZDb), lower.tail = FALSE))
# Result of the test
result <- ifelse(abs(ZDb) >= 1.64, 
c("aggregation or clustering"), 
c("randomness")) 
# Print the results
print(paste("There are",Db,"doublets. The number of expected doublets is",EDb,".","P-value:", round(pvalue,4), ". Alternative hypothesis: non-randomness"))
}
```

```{r}
# Run the function calling the vector
doublets.test(row1$y1)
```

### Joint count

Joint count statistics. Description.

![](imgs/spatial_jointcount.png){width="100%"}

Let's use the `join.count` function of the `spdep` package to perform a joint count test.

```{r}

# Enter the data
S2 <- c(1,1,1,1,0,
       0,1,0,0,1,
       1,0,1,0,0,
       1,0,0,1,1,
       0,0,0,0,1)
 
library (spdep)
nb <- cell2nb(5, 5, 
              type="rook", 
              torus=FALSE)
jc_rook <- joincount.test(factor(S2), 
                          nb2listw(nb, 
                                   style="B"))
jc_rook
#joincount.mc(factor(S2), nb2listw(nb, style="B"), nsim = 1000)
```

## Real examples

```{r}
library(epiphy)
series <- citrus_ctv$IVI3and4 %>% 
  filter(t == 1991) %>% 
  pull(i)

oruns.test(series)
runs.test(series, threshold = 0.5)
doublets.test(series)
```
